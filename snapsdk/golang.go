package main

import (
	"fmt"
	"strings"
)

type GoGenerator struct{}

func (GoGenerator) Name() string { return "go" }
func (g GoGenerator) Generate(snap Snap) (string, error) {
	var output strings.Builder

	fmt.Fprintf(&output, "// Generated by Snap version: %s\n", snap.Snap)
	fmt.Fprintf(&output, "package %s\n\n", strings.ToLower(snap.Namespace))

	// Collect all definitions (root-level and object-scoped)
	allDefs := make(map[string]Def)
	for name, def := range snap.Defs {
		allDefs[name] = def
	}
	for _, obj := range snap.Objects {
		for name, def := range obj.Definitions {
			allDefs[name] = def
		}
	}

	// Generate struct definitions.
	for name, def := range allDefs {
		fmt.Fprintf(&output, "type %s struct {\n", name)
		for propName, prop := range def.Properties {
			goType := prop.Type
			switch prop.Type {
			case "string":
				goType = "string"
			case "integer":
				goType = "int"
			case "boolean":
				goType = "bool"
			case "number":
				goType = "float64"
			}
			fmt.Fprintf(&output, "\t%s %s\n", strings.Title(propName), goType)
		}
		fmt.Fprintf(&output, "}\n\n")
	}

	// Generate code for each object and its methods.
	for objName, obj := range snap.Objects {
		for name, method := range obj.Methods {
			// Create a list of parameter names and types.
			paramNames := []string{}
			params := []string{}
			for _, param := range method.Parameters {
				// Map the Snap type to a Go type.
				goType := ""
				switch param.Type {
				case "string":
					goType = "string"
				case "integer":
					goType = "int"
				case "boolean":
					goType = "bool"
				case "number":
					goType = "float64"
				case "array":
					goType = "[]interface{}"
				default:
					// If the type is not a primitive, it must be a reference to a definition.
					if param.Ref != "" {
						refName := strings.Split(param.Ref, "/")[2] // Assuming '$ref' is like '#/definitions/User'
						goType = refName
					} else {
						goType = param.Type
					}
				}

				paramNames = append(paramNames, param.Name)
				params = append(params, fmt.Sprintf("%s %s", param.Name, goType))
			}

			// Write the function signature and doc comment.
			fmt.Fprintf(&output, "// %s\n", method.Description)
			fmt.Fprintf(&output, "func (o *%s) %s(%s) ", strings.Title(objName), strings.Title(name), strings.Join(params, ", "))

			// Handle return type if any
			if method.ReturnType != nil {
				retType := ""
				// Check if the ReturnType is a Ref to a definition
				if method.ReturnType.Ref != "" {
					retType = strings.Split(method.ReturnType.Ref, "/")[2] // Assuming '$ref' is like '#/definitions/User'
				} else if method.ReturnType.Type == "array" && method.ReturnType.Items != nil {
					refName := strings.Split(method.ReturnType.Items.Ref, "/")[2]
					retType = "[]" + refName
				} else {
					retType = method.ReturnType.Type
					switch retType {
					case "string":
						retType = "string"
					case "integer":
						retType = "int"
					case "boolean":
						retType = "bool"
					case "number":
						retType = "float64"
					}
				}

				if retType != "" {
					fmt.Fprintf(&output, "(%s, error) {\n", retType)
				} else {
					fmt.Fprintf(&output, "error {\n")
				}
			} else {
				fmt.Fprintf(&output, "error {\n")
			}

			// Generate a receiver call if receiver exists
			if receiver, ok := method.Receiver["go"]; ok {
				fmt.Fprintf(&output, "\treturn o.%s(%s)\n", receiver, strings.Join(paramNames, ", "))
			} else {
				// For now, just return.
				fmt.Fprintf(&output, "\t// return ...\n")
			}

			fmt.Fprintf(&output, "}\n\n")
		}
	}

	return output.String(), nil
}
