package main

import (
	"fmt"
	"sort"
	"strings"
)

type PythonGenerator struct{}

func (PythonGenerator) Name() string { return "py" }
func (p PythonGenerator) Generate(snap Snap) (string, error) {
	var output strings.Builder

	fmt.Fprintf(&output, "# Generated by Snap version: %s\n\n", snap.Snap)

	// Collect all definitions (root-level and object-scoped)
	allDefs := make(map[string]Def)
	for name, def := range snap.Defs {
		allDefs[name] = def
	}
	for _, obj := range snap.Objects {
		for name, def := range obj.Definitions {
			allDefs[name] = def
		}
	}

	// Generate definitions
	for name, def := range allDefs {
		fmt.Fprintf(&output, "class %s:\n", name)

		// Sort properties for stable output
		var propNames []string
		for propName := range def.Properties {
			propNames = append(propNames, propName)
		}
		sort.Strings(propNames)

		fmt.Fprintf(&output, "\tdef __init__(self, %s):\n", strings.Join(propNames, ", "))
		for _, propName := range propNames {
			fmt.Fprintf(&output, "\t\tself.%s = %s\n", propName, propName)
		}
		fmt.Fprintf(&output, "\n")
	}

	// Generate code for each object and its methods.
	for objName, obj := range snap.Objects {
		// Write the object.
		fmt.Fprintf(&output, "class %s:\n", objName)

		// Write the __init__ method.
		fmt.Fprintf(&output, "\tdef __init__(self):\n")
		fmt.Fprintf(&output, "\t\tpass\n")

		// Write each method.
		for name, method := range obj.Methods {
			// Create a list of parameter names.
			params := make([]string, len(method.Parameters))
			for i, param := range method.Parameters {
				params[i] = param.Name
			}

			// Write the method signature and docstring.
			fmt.Fprintf(&output, "\n\tdef %s(self, %s):\n", name, strings.Join(params, ", "))
			fmt.Fprintf(&output, "\t\t\"\"\"\n")
			fmt.Fprintf(&output, "\t\t%s\n", method.Description)
			fmt.Fprintf(&output, "\t\t\"\"\"\n")

			// Generate a receiver call if receiver exists
			if receiver, ok := method.Receiver["python"]; ok {
				fmt.Fprintf(&output, "\t\treturn self.%s(%s)\n", receiver, strings.Join(params, ", "))
			} else {
				// Generate a sample return value based on `method.ReturnType`.
				// For now, just return a placeholder object.
				fmt.Fprintf(&output, "\t\treturn %s\n", "{}")
			}
		}
	}

	return output.String(), nil
}
