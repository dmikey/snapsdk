package main

import (
	"fmt"
	"strings"
)

type RustGenerator struct{}

func (RustGenerator) Name() string { return "rs" }
func (r RustGenerator) Generate(snap Snap) (string, error) {
	var output strings.Builder

	fmt.Fprintf(&output, "// Generated by Snap version: %s\n\n", snap.Snap)
	fmt.Fprintf(&output, "#[allow(dead_code)]\n")
	fmt.Fprintf(&output, "pub mod %s {\n", strings.ToLower(snap.Namespace))

	// Collect all definitions (root-level and object-scoped)
	allDefs := make(map[string]Def)
	for name, def := range snap.Defs {
		allDefs[name] = def
	}
	for _, obj := range snap.Objects {
		for name, def := range obj.Definitions {
			allDefs[name] = def
		}
	}

	// Generate struct definitions.
	for name, def := range allDefs {
		fmt.Fprintf(&output, "\t#[derive(Debug)]\n")
		fmt.Fprintf(&output, "\tpub struct %s {\n", name)
		for propName, prop := range def.Properties {
			fmt.Fprintf(&output, "\t\tpub %s: %s,\n", strings.ToLower(propName), r.mapType(prop.Type))
		}
		fmt.Fprintf(&output, "\t}\n\n")
	}

	// Generate code for each object and its methods.
	for _, obj := range snap.Objects {
		for name, method := range obj.Methods {
			// Create a list of parameter names and types.
			params := []string{}
			for _, param := range method.Parameters {
				paramType := r.mapType(param.Type)
				// If the type is a reference to a definition, get the actual name.
				if param.Ref != "" {
					refName := strings.Split(param.Ref, "/")[2] // Assuming '$ref' is like '#/definitions/User'
					paramType = refName
				}
				params = append(params, fmt.Sprintf("%s: %s", param.Name, paramType))
			}

			// Write the method signature and doc comment.
			fmt.Fprintf(&output, "\t/// %s\n", method.Description)

			returnTypeStr := ""
			if method.ReturnType != nil {
				if method.ReturnType.Ref != "" {
					returnTypeStr = strings.Split(method.ReturnType.Ref, "/")[2]
				} else if method.ReturnType.Type == "array" && method.ReturnType.Items != nil {
					if method.ReturnType.Items.Ref != "" {
						innerType := strings.Split(method.ReturnType.Items.Ref, "/")[2]
						returnTypeStr = fmt.Sprintf("Vec<%s>", innerType)
					}
				} else {
					// Primitive return
					if method.ReturnType.Type != "" {
						returnTypeStr = r.mapType(method.ReturnType.Type)
					}
				}
			}

			if returnTypeStr != "" {
				fmt.Fprintf(&output, "\tpub fn %s(&self, %s) -> Result<%s, Error> {\n", strings.ToLower(name), strings.Join(params, ", "), returnTypeStr)
			} else {
				fmt.Fprintf(&output, "\tpub fn %s(&self, %s) {\n", strings.ToLower(name), strings.Join(params, ", "))
			}

			// Generate a receiver call if receiver exists
			if receiver, ok := method.Receiver["rust"]; ok {
				fmt.Fprintf(&output, "\t\tself.%s(%s)\n", receiver, strings.Join(params, ", "))
			} else {
				// For now, just return.
				fmt.Fprintf(&output, "\t\t// return ...\n")
			}

			fmt.Fprintf(&output, "\t}\n\n")
		}
	}

	fmt.Fprintf(&output, "}\n")

	return output.String(), nil
}

// mapType maps a Snap type to a Rust type.
func (r RustGenerator) mapType(snapType string) string {
	switch snapType {
	case "string":
		return "String"
	case "integer":
		return "i32"
	case "boolean":
		return "bool"
	case "array":
		return "Vec<T>" // TODO: Replace T with the actual type of the elements.
	default:
		return snapType
	}
}
